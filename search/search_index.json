{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pygitops - 0.9.0 pygitops provides a convenience layer for developers wishing to automate git workflows with python. Best of all, it works extremely well with GitPython as well as PyGithub ! pygitops ' feature set improves the experience of: cloning git repositories keeping local repositories up to date with their remotes making code changes on a repository feature branch staging, commiting, and pushing changes to remote Examples Cloning Repo Most automated git workflows involve interacting with a local clone of a repo. You might want to begin by having a copy of that repository on your local disk. pygitops will clone the repository for you, updating it when already present. from pygitops.operations import build_github_repo_url , get_updated_repo service_account_name = 'some-service-account-name' service_account_token = 'some-service-account-token' repo_owner = 'wayfair-incubator' repo_name = 'pygitops' repo_url = build_github_repo_url ( service_account_name , service_account_token , repo_owner , repo_name ) repo = get_updated_repo ( repo_url , '/repos' , repo_name ) Using GitPython The repo returned by get_updated_repo is an instance of git.Repo , from the GitPython package. If you are already familiar with the package and need to leverage its functionality, pygitops won't get in your way! >>> from git import Repo >>> repo = Repo ( 'some-repo' ) >>> repo . working_dir 'User/repos/some-repo' Commiting Change A common git automation use case is to commit some changes; pushing them to a remote feature branch. Here, we create a new file chores.txt and commit / push that change to the new-chores feature branch. You may then want to use PyGithub to create a pull request from these changes. from pathlib import Path from pygitops.operations import feature_branch , stage_commit_push_changes from git import Actor repo_name = 'some-repo' branch_name = 'new-chores' some_actor = Actor ( 'some-service-account' , 'some-service-account@some-enterprise.com' ) commit_message = 'Add list of chores' with feature_branch ( repo , branch_name ): Path ( 'some-clone-dir' / repo_name / 'chores.txt' ) . write_text ( 'haircut \\n groceries \\n dishes' ) stage_commit_push_changes ( repo , branch_name , some_actor , commit_message ) Where to Start? TODO Detailed Documentation TODO API Reference TODO","title":"Overview"},{"location":"#pygitops-090","text":"pygitops provides a convenience layer for developers wishing to automate git workflows with python. Best of all, it works extremely well with GitPython as well as PyGithub ! pygitops ' feature set improves the experience of: cloning git repositories keeping local repositories up to date with their remotes making code changes on a repository feature branch staging, commiting, and pushing changes to remote","title":"pygitops - 0.9.0"},{"location":"#examples","text":"","title":"Examples"},{"location":"#cloning-repo","text":"Most automated git workflows involve interacting with a local clone of a repo. You might want to begin by having a copy of that repository on your local disk. pygitops will clone the repository for you, updating it when already present. from pygitops.operations import build_github_repo_url , get_updated_repo service_account_name = 'some-service-account-name' service_account_token = 'some-service-account-token' repo_owner = 'wayfair-incubator' repo_name = 'pygitops' repo_url = build_github_repo_url ( service_account_name , service_account_token , repo_owner , repo_name ) repo = get_updated_repo ( repo_url , '/repos' , repo_name )","title":"Cloning Repo"},{"location":"#using-gitpython","text":"The repo returned by get_updated_repo is an instance of git.Repo , from the GitPython package. If you are already familiar with the package and need to leverage its functionality, pygitops won't get in your way! >>> from git import Repo >>> repo = Repo ( 'some-repo' ) >>> repo . working_dir 'User/repos/some-repo'","title":"Using GitPython"},{"location":"#commiting-change","text":"A common git automation use case is to commit some changes; pushing them to a remote feature branch. Here, we create a new file chores.txt and commit / push that change to the new-chores feature branch. You may then want to use PyGithub to create a pull request from these changes. from pathlib import Path from pygitops.operations import feature_branch , stage_commit_push_changes from git import Actor repo_name = 'some-repo' branch_name = 'new-chores' some_actor = Actor ( 'some-service-account' , 'some-service-account@some-enterprise.com' ) commit_message = 'Add list of chores' with feature_branch ( repo , branch_name ): Path ( 'some-clone-dir' / repo_name / 'chores.txt' ) . write_text ( 'haircut \\n groceries \\n dishes' ) stage_commit_push_changes ( repo , branch_name , some_actor , commit_message )","title":"Commiting Change"},{"location":"#where-to-start","text":"TODO","title":"Where to Start?"},{"location":"#detailed-documentation","text":"TODO","title":"Detailed Documentation"},{"location":"#api-reference","text":"TODO","title":"API Reference"},{"location":"development-guide/","text":"Development Guide Welcome - Thank you for wanting to make this project better! This section provides an overview on how the repository is structured and how to work with the codebase. Before you dive into this guide, please read the following first: The Code of Conduct The Contributing Guide Docker The pygitops project uses Docker to ease setting up a consistent development environment. The Docker documentation has details on how to install Docker and install Docker Compose on your computer. Once you have installed Docker and Docker Compose, you can execute the test suite by running the following command from your terminal: docker-compose run --rm test If you want to be able to execute code in the container: docker-compose run --rm devbox ( your code here ) In the devbox environment you'll be able to enter a Python shell and import pygitops or any dependencies. The devbox environment also comes with git-core - a system dependency needed to run gitpython , our package's main dependency. Debugging The Docker container has pdb++ installed that can be used as a debugger. (However, you are welcome to set up a different debugger if you would like.) This allows you to easily create a breakpoint anywhere in the code. def my_function (): breakpoint () ... When you run your code, you will drop into an interactive pdb++ debugger. See the documentation on pdb and pdb++ for more information. Testing You'll be unable to merge code unless the linting and tests pass. You can run these in your container via: docker-compose run --rm test This will run the same tests, linting, and code coverage that are run by the CI pipeline. The only difference is that when run locally, black and isort are configured to automatically correct issues they detect. Generally we should endeavor to write tests for every feature. Every new feature branch should increase the test coverage rather than decrease it. We use pytest as our testing framework. Stages To customize / override a specific testing stage, please read the documentation specific to that tool: PyTest MyPy Black Isort Flake8 Bandit setup.py Setuptools is used to package the library. setup.py must not import anything from the package When installing from source, the user may not have the packages' dependencies installed, and importing the package is likely to raise an ImportError . For this reason, the package version should be obtained without importing . This explains why setup.py uses a regular expression to grab the version from __init__.py without actually importing any dependencies. Requirements requirements.txt - Lists all direct dependencies (packages imported by the library). Requirements-test.txt - Lists all direct requirements needed to run the test suite & lints. Publishing the Package TODO: Document package publish process Continuous Integration Pipeline TODO: Add CI documentation.","title":"Development Guide"},{"location":"development-guide/#development-guide","text":"Welcome - Thank you for wanting to make this project better! This section provides an overview on how the repository is structured and how to work with the codebase. Before you dive into this guide, please read the following first: The Code of Conduct The Contributing Guide","title":"Development Guide"},{"location":"development-guide/#docker","text":"The pygitops project uses Docker to ease setting up a consistent development environment. The Docker documentation has details on how to install Docker and install Docker Compose on your computer. Once you have installed Docker and Docker Compose, you can execute the test suite by running the following command from your terminal: docker-compose run --rm test If you want to be able to execute code in the container: docker-compose run --rm devbox ( your code here ) In the devbox environment you'll be able to enter a Python shell and import pygitops or any dependencies. The devbox environment also comes with git-core - a system dependency needed to run gitpython , our package's main dependency.","title":"Docker"},{"location":"development-guide/#debugging","text":"The Docker container has pdb++ installed that can be used as a debugger. (However, you are welcome to set up a different debugger if you would like.) This allows you to easily create a breakpoint anywhere in the code. def my_function (): breakpoint () ... When you run your code, you will drop into an interactive pdb++ debugger. See the documentation on pdb and pdb++ for more information.","title":"Debugging"},{"location":"development-guide/#testing","text":"You'll be unable to merge code unless the linting and tests pass. You can run these in your container via: docker-compose run --rm test This will run the same tests, linting, and code coverage that are run by the CI pipeline. The only difference is that when run locally, black and isort are configured to automatically correct issues they detect. Generally we should endeavor to write tests for every feature. Every new feature branch should increase the test coverage rather than decrease it. We use pytest as our testing framework.","title":"Testing"},{"location":"development-guide/#stages","text":"To customize / override a specific testing stage, please read the documentation specific to that tool: PyTest MyPy Black Isort Flake8 Bandit","title":"Stages"},{"location":"development-guide/#setuppy","text":"Setuptools is used to package the library. setup.py must not import anything from the package When installing from source, the user may not have the packages' dependencies installed, and importing the package is likely to raise an ImportError . For this reason, the package version should be obtained without importing . This explains why setup.py uses a regular expression to grab the version from __init__.py without actually importing any dependencies.","title":"setup.py"},{"location":"development-guide/#requirements","text":"requirements.txt - Lists all direct dependencies (packages imported by the library). Requirements-test.txt - Lists all direct requirements needed to run the test suite & lints.","title":"Requirements"},{"location":"development-guide/#publishing-the-package","text":"TODO: Document package publish process","title":"Publishing the Package"},{"location":"development-guide/#continuous-integration-pipeline","text":"TODO: Add CI documentation.","title":"Continuous Integration Pipeline"}]}